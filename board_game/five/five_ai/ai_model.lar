import util;

//feature按每2bit表示一个位置状态，例如“oo x o”表示为0b101000010010
final uint FEATURE_LEN = 6;

uint feature_stat(uint f, uint i)
{
    assert(i < FEATURE_LEN, "bug");
    return (f >> (i * 2)) & 0b11;
}

void set_feature_stat(ref uint f, uint i, uint stat)
{
    assert(feature_stat(f, i) == 0 && stat <= 2, "bug");
    f |= stat << (i * 2);
}

bool std_feature(ref uint f)
{
    uint rf = 0;
    for (uint i = 0; i < FEATURE_LEN; ++ i)
    {
        var stat = feature_stat(f, i);
        if (stat == 3)
        {
            return false;
        }
        set_feature_stat(ref rf, FEATURE_LEN - 1 - i, stat);
    }
    f = util.min(f, rf);
    return true;
}

//反转feature的双方棋子
uint rev_feature(uint f)
{
    uint rev_f = 0;
    for (uint i = 0; i < FEATURE_LEN; ++ i)
    {
        var stat = feature_stat(f, i);
        if (stat == 1 || stat == 2)
        {
            set_feature_stat(ref rev_f, i, 3 - stat);
        }
        else
        {
            assert(stat == 0, "bug");
        }
    }
    assert(std_feature(ref rev_f), "bug");
    return rev_f;
}

String format_feature(uint f)
{
    String s = "Feature[";
    for (uint i = 0; i < FEATURE_LEN; ++ i)
    {
        if (i != 0)
        {
            s = s.concat(",");
        }
        s = s.concat("%s".(feature_stat(f, i)));
    }
    return s.concat("]");
}

class FeatureInfo
{
    FeatureInfo(uint[] step_2_count)
    {
        assert(step_2_count.size() == 6, "bug");
        this.step_2_count = step_2_count;
        this.score_factor = 0.0;
        double factor = 1.0;
        for (int i = 0; i < 6; ++ i)
        {
            this.score_factor += factor * (double)this.step_2_count[i];
            factor /= 8.0;
        }
    }

    uint[] step_2_count;
    double score_factor;
}

util.HashMap<uint, FeatureInfo> feature_info_map;
util.HashMap<uint, double> weight_map;
double[] score_map;

FeatureInfo calc_feature_info(uint f)
{
    var it = feature_info_map.find(f);
    if (it != nil)
    {
        return it.value();
    }

    var step_2_count = new uint[6];

    //判断是否已经五联了
    uint continue_count = 0;
    for (uint i = 0; i < FEATURE_LEN; ++ i)
    {
        if (feature_stat(f, i) == 2)
        {
            ++ continue_count;
            if (continue_count >= 5)
            {
                break;
            }
        }
        else
        {
            continue_count = 0;
        }
    }
    if (continue_count >= 5)
    {
        //存在五联，结束
        step_2_count[0] = 1;
    }
    else
    {
        //不存在，对所有空位依次下子并进行dfs来计算step_2_count
        for (uint i = 0; i < FEATURE_LEN; ++ i)
        {
            if (feature_stat(f, i) == 0)
            {
                uint new_f = f;
                set_feature_stat(ref new_f, i, 2);
                assert(std_feature(ref new_f), "bug");
                var feature_info = calc_feature_info(new_f);
                for (uint step = 1; step < 6; ++ step)
                {
                    step_2_count[step] += feature_info.step_2_count[step - 1];
                }
            }
        }
    }

    var r = new FeatureInfo(step_2_count);
    feature_info_map.set(f, r);
    return r;
}

final Pair<uint, double>[] RECOMMEND_WEIGHT = new Pair<uint, double>[]{
    0:         1.890050832027,
    1:         1.399427178242,
    2:         1.548160518120,
    8:         1.270321995086,
    9:         1.110704267373,
    10:        1.394592043607,
    32:        1.347808418892,
    33:        1.202895435242,
    34:        2.691017476585,
    40:        2.470423898186,
    41:        2.461446951268,
    42:        1.792313054420,
    129:       1.703734620573,
    130:       2.021368564729,
    136:       2.256969480176,
    137:       1.597098599613,
    138:       1.025161367930,
    160:       1.297265844303,
    161:       1.321635102990,
    162:       2.716262883030,
    168:       2.236795641604,
    169:       1.710996645856,
    170:       1.163877672582,
    513:       1.764091287500,
    514:       1.098697729356,
    520:       1.427295397191,
    521:       1.635285539212,
    522:       1.028824752426,
    545:       1.808264884298,
    546:       1.422450282083,
    552:       1.295811527651,
    553:       1.496396382321,
    554:       1.651707527344,
    641:       2.247224174824,
    642:       2.096885641777,
    649:       1.391789806594,
    650:       2.100138437753,
    673:       2.701200081029,
    674:       1.142195541367,
    680:       2.502125014221,
    681:       1.911928641963,
    682:       1.556065652275,
    1026:      1.623580089669,
    1034:      1.186698212285,
    1058:      2.114725708173,
    1066:      1.093384084921,
    1154:      1.252159665091,
    1162:      1.734937408556,
    1186:      1.310473609139,
    1194:      2.396731857558,
    1538:      2.007096607735,
    1546:      2.171756269087,
    1570:      2.515411770944,
    1578:      1.557301681979,
    1666:      1.252392475437,
    1674:      1.427760941676,
    1698:      1.190396042768,
    1706:      1.259970919625,
    2050:      1.548783651520,
    2058:      2.046049787679,
    2082:      1.002671923474,
    2090:      1.806963727993,
    2186:      2.522346162884,
    2210:      2.292345256722,
    2218:      2.001851542401,
    2570:      1.512591774714,
    2602:      1.568330968205,
    2730:      1.834058214070,
};

final bool NO_SCORE_FACTOR = false;

public void init_ai_model()
{
    assert(FEATURE_LEN > 5, "bug"); //限制一下特征长度，需要比5大

    feature_info_map = new util.HashMap<uint, FeatureInfo>(nil);
    weight_map = new util.HashMap<uint, double>(nil);
    score_map = new double[1 << (2 * FEATURE_LEN)];

    uint feature_count = 1U << (2 * FEATURE_LEN);
    for (uint fi = 0; fi < feature_count; ++ fi)
    {
        uint f = fi;
        if (std_feature(ref f))
        {
            calc_feature_info(f);
        }
    }
    var zero_score_factor_feature_list = new util.Vector<uint>(nil);
    foreach (var kv: feature_info_map.iter())
    {
        if (kv.second.score_factor == 0.0)
        {
            zero_score_factor_feature_list.add(kv.first);
        }
    }
    foreach (var f: zero_score_factor_feature_list.iter())
    {
        feature_info_map.pop(f);
    }
    if (NO_SCORE_FACTOR)
    {
        foreach (var kv: feature_info_map.iter())
        {
            kv.second.score_factor = 1.0;
        }
    }
    foreach (var kv: feature_info_map.iter())
    {
        weight_map.set(kv.first, 1);
    }
    weight_map.update(RECOMMEND_WEIGHT.iter());
    foreach (var kv: feature_info_map.iter())
    {
        score_map[kv.first] = kv.second.score_factor * weight_map.get(kv.first);
    }
}

double feature_score(uint f)
{
    //分别计算我方和对方的分值，返回分值差
    return score_map[f] - score_map[rev_feature(f)];
}

uint line_to_feature(char[] line)
{
    assert(line.size() == (long)FEATURE_LEN, "bug");
    uint f = 0;
    for (uint i = 0; i < FEATURE_LEN; ++ i)
    {
        set_feature_stat(ref f, i, (uint)line[i]);
    }
    assert(std_feature(ref f), "bug");
    return f;
}
