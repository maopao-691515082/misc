import math/rand, util, time;

final int AI_DEEP = 2;

class Pos
{
    Pos(long row, long col)
    {
        this.row = row;
        this.col = col;
    }

    public String repr()
    {
        return "(%c,%c)".("ABCDEFGHIJKLMNOPQRSTUVWXYZ".char_at(this.row), "abcdefghijklmnopqrstuvwxyz".char_at(this.col));
    }

    long row, col;
}

class Stat
{
    Stat(char[][] board)
    {
        this.board = board;
        this.board_size = board.size();
        this.pos_list = new util.Vector<Pos>(nil);
        this.playable = new char[this.board_size][this.board_size];
        this.cell_count = 0;

        for (long row = 0; row < this.board_size; ++ row)
        {
            for (long col = 0; col < this.board_size; ++ col)
            {
                this.pos_list.add(new Pos(row, col));
                if (board[row][col] != 0)
                {
                    this.set_playable(row, col);
                    ++ this.cell_count;
                }
            }
        }
        if (this.cell_count == this.board_size * this.board_size)
        {
            throw(new InvalidReq());
        }

        this.feature_map = new long[1 << (FEATURE_LEN * 2)];
        for (long row = 0; row < this.board_size; ++ row)
        {
            for (long col = 0; col < this.board_size; ++ col)
            {
                //横向
                if (col + (long)FEATURE_LEN <= this.board_size)
                {
                    this.inc_feature(this.board[row][col : col + (long)FEATURE_LEN]);
                }

                //纵向
                if (row + (long)FEATURE_LEN <= this.board_size)
                {
                    var line = new char[FEATURE_LEN];
                    for (long i = 0; i < (long)FEATURE_LEN; ++ i)
                    {
                        line[i] = this.board[row + i][col];
                    }
                    this.inc_feature(line);
                }

                //右下方
                if (row + (long)FEATURE_LEN <= this.board_size && col + (long)FEATURE_LEN <= this.board_size)
                {
                    var line = new char[FEATURE_LEN];
                    for (long i = 0; i < (long)FEATURE_LEN; ++ i)
                    {
                        line[i] = this.board[row + i][col + i];
                    }
                    this.inc_feature(line);
                }

                //左下方
                if (row + (long)FEATURE_LEN <= this.board_size && col - ((long)FEATURE_LEN - 1) >= 0)
                {
                    var line = new char[FEATURE_LEN];
                    for (long i = 0; i < (long)FEATURE_LEN; ++ i)
                    {
                        line[i] = this.board[row + i][col - i];
                    }
                    this.inc_feature(line);
                }
            }
        }
    }

    void inc_feature(char[] line)
    {
        this.adjust_feature_count(line, 1);
    }

    void dec_feature(char[] line)
    {
        this.adjust_feature_count(line, -1L);
    }

    void adjust_feature_count(char[] line, long adj)
    {
        var f = line_to_feature(line);
        if (feature_score(f) != 0.0)
        {
            var count = this.feature_map[f] + adj;
            assert(count >= 0, "bug");
            this.feature_map[f] = count;
        }
    }

    //(row,col)位置是有子的，这里是设置以其为中心的一片格子为playable
    void set_playable(long row, long col)
    {
        this.adjust_playable(row, col, 1);
    }

    //set_playable的反操作，参考其注释
    void unset_playable(long row, long col)
    {
        this.adjust_playable(row, col, -1);
    }

    void adjust_playable(long row, long col, int adj)
    {
        //五步以内只考虑3x3范围，之后考虑5x5
        long range = 2;
        if (this.cell_count < 5)
        {
            range = 1;
        }
        var x_min = util.max(0L, row - range),
            x_max = util.min(this.board_size - 1, row + range),
            y_min = util.max(0L, col - range),
            y_max = util.min(this.board_size - 1, col + range);
        for (long x = x_min; x <= x_max; ++ x)
        {
            for (long y = y_min; y <= y_max; ++ y)
            {
                var new_val = (int)this.playable[x][y] + adj;
                assert(new_val >= 0, "bug");
                this.playable[x][y] = (char)new_val;
            }
        }
    }

    util.Vector<Pos> playable_pos_list()
    {
        var l = new util.Vector<Pos>(nil);
        foreach (var pos: this.pos_list.iter())
        {
            if (this.board[pos.row][pos.col] == 0 && this.playable[pos.row][pos.col] != 0)
            {
                l.add(pos);
            }
        }
        if (l.size() == 0)
        {
            var center = this.board_size / 2;
            if (this.board[center][center] == 0)
            {
                l.add(new Pos(center, center));
            }
        }
        rand.shuffle(l);
        return l;
    }

    Pos ai_choice(char cell_stat, int deep, ref double score_result, double ab_score_result, bool ab_score_result_inited)
    {
        if (deep <= 0)
        {
            score_result = this.calc_score();
            return nil;
        }

        var ppl = this.playable_pos_list();
        if (ppl.size() == 0)
        {
            score_result = this.calc_score();
            return nil;
        }

        Pos pos_result = nil;
        bool score_result_inited = false;
        foreach (var pos: ppl.iter())
        {
            this.set_cell(cell_stat, pos);
            double score;
            this.ai_choice(3 - cell_stat, deep - 1, ref score, score_result, score_result_inited);
            this.unset_cell(cell_stat, pos);

            if (cell_stat == 2)
            {
                if (!score_result_inited || score > score_result)
                {
                    pos_result = pos;
                    score_result = score;
                    score_result_inited = true;
                }
                if (ab_score_result_inited && score_result > ab_score_result)
                {
                    break;
                }
            }
            else
            {
                assert(cell_stat == 1, "bug");
                if (!score_result_inited || score < score_result)
                {
                    pos_result = pos;
                    score_result = score;
                    score_result_inited = true;
                }
                if (ab_score_result_inited && score_result < ab_score_result)
                {
                    break;
                }
            }
        }

        assert(pos_result != nil && score_result_inited, "bug");
        return pos_result;
    }

    double calc_score()
    {
double ts = time.time();
        double score = 0.0;
        for (long i = 0; i < this.feature_map.size(); ++ i)
        {
            if (this.feature_map[i] == 0)
            {
                continue;
            }
            score += feature_score((uint)i) * (double)this.feature_map[i];
        }
this.step_tm += time.time() - ts;
        return score;
    }

    //模拟下子，修改状态
    void set_cell(char cell_stat, Pos pos)
    {
        assert(this.board[pos.row][pos.col] == 0 && (cell_stat == 1 || cell_stat == 2), "bug");

        this.remove_feature_with_pos(pos);

        this.board[pos.row][pos.col] = cell_stat;
        ++ this.cell_count;
        this.set_playable(pos.row, pos.col);

        this.add_feature_with_pos(pos);
    }

    //set_cell的反操作，回退之前的下子和状态变动
    void unset_cell(char cell_stat, Pos pos)
    {
        assert((cell_stat == 1 || cell_stat == 2) && this.board[pos.row][pos.col] == cell_stat, "bug");

        this.remove_feature_with_pos(pos);

        this.unset_playable(pos.row, pos.col);
        -- this.cell_count;
        this.board[pos.row][pos.col] = 0;

        this.add_feature_with_pos(pos);
    }

    void add_feature_with_pos(Pos pos)
    {
        this.adjust_feature_count_with_pos(pos, false);
    }

    void remove_feature_with_pos(Pos pos)
    {
        this.adjust_feature_count_with_pos(pos, true);
    }

    void adjust_feature_count_with_pos(Pos pos, bool is_dec)
    {
        /*
        var adj_func = []{
            void call(char[] line)
            {
                if (is_dec)
                {
                    this.dec_feature(line);
                }
                else
                {
                    this.inc_feature(line);
                }
            }
        };
        */
        long adj_count = 1;
        if (is_dec)
        {
            adj_count = -1L;
        }

        var line = new char[FEATURE_LEN];

        //横向
        for (long col = pos.col - ((long)FEATURE_LEN - 1); col <= pos.col; ++ col)
        {
            if (col >= 0 && col + (long)FEATURE_LEN <= this.board_size)
            {
                //adj_func.call(this.board[pos.row][col : col + (long)FEATURE_LEN]);
                this.adjust_feature_count(this.board[pos.row][col : col + (long)FEATURE_LEN], adj_count);
            }
        }

        //纵向
        for (long row = pos.row - ((long)FEATURE_LEN - 1); row <= pos.row; ++ row)
        {
            if (row >= 0 && row + (long)FEATURE_LEN <= this.board_size)
            {
                for (long i = 0; i < (long)FEATURE_LEN; ++ i)
                {
                    line[i] = this.board[row + i][pos.col];
                }
                //adj_func.call(line);
                this.adjust_feature_count(line, adj_count);
            }
        }

        //左上到右下
        for (long row = pos.row - ((long)FEATURE_LEN - 1), col = pos.col - ((long)FEATURE_LEN - 1); row <= pos.row && col <= pos.col;
             ++ row, ++ col)
        {
            if (row >= 0 && row + (long)FEATURE_LEN <= this.board_size && col >= 0 && col + (long)FEATURE_LEN <= this.board_size)
            {
                for (long i = 0; i < (long)FEATURE_LEN; ++ i)
                {
                    line[i] = this.board[row + i][col + i];
                }
                //adj_func.call(line);
                this.adjust_feature_count(line, adj_count);
            }
        }

        //右上到左下
        for (long row = pos.row - ((long)FEATURE_LEN - 1), col = pos.col + ((long)FEATURE_LEN - 1); row <= pos.row && col >= pos.col;
             ++ row, -- col)
        {
            if (row >= 0 && row + (long)FEATURE_LEN <= this.board_size && col - ((long)FEATURE_LEN - 1) >= 0 && col < this.board_size)
            {
                for (long i = 0; i < (long)FEATURE_LEN; ++ i)
                {
                    line[i] = this.board[row + i][col - i];
                }
                //adj_func.call(line);
                this.adjust_feature_count(line, adj_count);
            }
        }
    }

    char[][] board;
    long board_size;
    util.Vector<Pos> pos_list;
    char[][] playable;
    long cell_count;
    long[] feature_map; //{feature:count}

    double step_tm;
}

final bool FOOLISH = false;

Pos ai_choice(char[][] board)
{
    if (FOOLISH)
    {
        for (long row = 0; row < board.size(); ++ row)
        {
            for (long col = 0; col < board.size(); ++ col)
            {
                if (board[row][col] == 0)
                {
                    return new Pos(row, col);
                }
            }
        }
        throw("full");
    }
    var stat = new Stat(board);
    double score;
    var pos = stat.ai_choice(2, AI_DEEP, ref score, 0.0, false);
    println("ppl time: %.2f sec".(stat.step_tm));
    return pos;
}
